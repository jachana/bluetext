# Polytope Documentation Reference

This file contains comprehensive documentation about Polytope, a job runner platform that uses computational graphs based on steps and modules.

Do not try to test the functionality you generate. You don't know enough about how Polytope works to be able to do that in a reliable way. 

When adding a Polytope module for which there is a Blueprint, always use the MCP server to fetch the appropriate blueprint resource. Use the `access_mcp_resource` tool with the server name `bluetext` and the URI `bluetext://blueprints/<blueprint-id>` where `<blueprint-id>` is the specific blueprint you need.

## Core Concepts

### Jobs and Steps
- A **job** is a computational graph based on one or more **steps** arranged in any configuration
- Each step runs a **module** which executes code against Polytope's runner API
- Modules can spawn containers, save datasets, create services, and perform other actions

### Modules
- Modules are the core building blocks of Polytope
- Each step runs a module that interfaces with Polytope's runner API
- Polytope provides a set of built-in standard modules for common use cases
- Custom modules can be defined using the same interface
- Modules typically accept parameter input conforming to specified types
- Modules can run code snippets directly or wrap other modules

#### Standard Modules
Polytope includes several built-in standard modules that are available even though they are not defined in your `polytope.yml` file. These modules should be referenced with a `polytope/` prefix (e.g., `polytope/redpanda` where the module-id is `redpanda` and the module-reference is `polytope/redpanda`).

When you need to understand how a specific standard module functions, use the MCP server to fetch the relevant standard module resource with the URI `bluetext://polytope/standard-modules/<module-id>`.

**Available Standard Modules:**

| Module ID | Summary |
|-----------|---------|
| `redpanda` | Runs a single Redpanda node in development mode with Kafka-compatible streaming |
| `redpanda!console` | Runs the Redpanda Console web UI for managing and monitoring Kafka/Redpanda clusters |
| `redpanda!connect` | Runs Redpanda Connect for building real-time data streaming and transformation pipelines |
| `postgres` | Runs a PostgreSQL database container with full configuration options |
| `postgres!simple` | Runs a PostgreSQL container with minimal configuration for development use |
| `python` | Runs a Python container with full configuration options for applications and services |
| `python!simple` | Runs a Python container with minimal configuration for simple applications |
| `container` | Runs a Docker container with full configuration options - the foundational module |
| `node` | Runs a Node.js container with full configuration options for JavaScript applications |

### Templates
- Templates specify full jobs
- Define what steps to run for easy reuse
- Specified using TemplateSpec data type

### Configuration Files
- Modules, templates, and triggers are defined in Polytope files
- Supported formats: `polytope.yml`, `polytope.json`, or `polytope.edn`
- Typically a `polytope.yml` file is placed at the repo root.

### Other Key Concepts
- **Containers**: Docker containers spawned by steps, with replication and autoscaling support
- **Datasets**: Versioned data that can be used as step inputs/outputs
- **Services**: Expose container ports for interaction (localhost for CLI, autogenerated URLs for web service)
- **Values**: Built-in key-value store for steps to read/write
- **Volumes**: Share data between containers or persist data across job runs
- **Triggers**: Run jobs on schedule or following specific events
- **Projects**: Work organization unit in web service, can be owned by users or organizations

## polytope.yml file
The contents of the polytope.yml file must follow the schema `PolytopeFile` from `data_types_yaml_specification.yml` (henceforth: "the definitions file").

The Polytope file has the top-level keys `modules` and `templates`:
- `modules` is a list of module declarations. Modules are encapsulated, reusable snippets of code that take a (possibly empty) set of arguments, and either call another module, or run a snippet of code. Typically modules perform some simple task, like running a container.
- `templates` is a list of template declarations. Each template declaration is a list of module calls. Possibly with ordering dependencies. Templates can also take arguments.

### `modules`
`modules` holds a list of module specs. These specs must adhere to the `ModuleSpec` type in the definitions file.

The following keys are supported when defining a module:
- `id`: Uniquely identifies a module. May only contain '0–9', 'a–z', '_', and '-'. Required.
- `ìnfo`: Optional info string about the module.
- `params`: Parameter declarations for the module. When calling the module, the provided args must match this declaration. Explained in detail below. Optional.
- `module`: Defines another module that this module will call. Not compatible with `code`. Required unless `code` is provided.
- `args`: Arguments to pass as parameters to the module referenced via `module`. Must match the parameters declared in that module. Explained in detail below. Required if the module being called has required parameters.
- `code`: Only provided for modules that run code directly. Not compatible with `args` or `module`. Inline code written in Clojure or JavaScript that runs against the module API.

#### Example
```yaml
# Basic module that prints a user-defined message with a default value:
info: Prints a message to the logs.
id: hello-world
params:
- id: message
  info: The message to be printed.
  name: Message
  type: [default, str, Hello world!]
code: '#pt-clj (println (:message params))'

# Module that calls another module:
info: Runs a PostgreSQL container.
id: postgres
params:
- id: image
  info: The Docker image to run.
  name: Image
  type: [default, docker-image, 'public.ecr.aws/docker/library/postgres:16.2']
- id: container-id
  info: The ID to use for the container.
  name: Container ID
  type: [default, str, postgres]
- id: data-volume
  name: Data Volume
  info: The volume (if any) to mount for data.
  type: [maybe, mount-source]
- id: service-id
  info: The ID to use for the service.
  name: Service ID
  type: [default, str, postgres]
- id: env
  info: Environment variables to pass to the server.
  name: Environment variables
  type: [maybe, [env-var]]
- id: cmd
  info: The command to run in the container. If unspecified, runs the PostgreSQL server.
  name: Command
  type: [maybe, [either, str, [str]]]
- id: restart
  info: What policy to apply on restarting containers that fail.
  name: Restart policy
  type: [maybe, {policy: [enum, always, on-failure], max-restarts: [maybe, int]}]
- id: scripts
  info: SQL files to run when initializing the DB.
  name: Scripts
  type: [maybe, [mount-source]]
module: polytope/container
args:
  image: pt.param image
  id: pt.param container-id
  mounts: |-
    pt.clj
    (concat
     (when-let [v (:data-volume params)]
      [{:path "/var/lib/postgresql/data", :source v}])
     (for [s (:scripts params)]
      {:path   "/docker-entrypoint-initdb.d/data-backup.sql"
       :source s}))
  env: pt.param env
  tty: "pt.clj (empty? (:scripts params))"
  restart: pt.param restart
  services:
  - id: pt.param service-id
    ports: [{protocol: tcp, port: 5432}]
```

#### params
Module parameters are declared via the `params` key, which must be a list of `ParamSpec`. If this key is not present, the module has no parameters.

`ParamSpec`s have the following keys:
- `id`: the name of the parameter. Required.
- `type`: a data structure defining the type of the argument. Must follow the param type DSL, explained below. Required.
- `ìnfo`: Optional info string about the param.

##### Example
```
params:
  - id: foo
    type: [default, {foo: str}, {foo: bar}] # has a default value so does not need to be provided
  - id: bar
  - type: [maybe, str] # optional parameter, can be omitted
  - id: env-vars
    type: [env-var] # a list of environment variables - no default or maybe, so must be provided
```

#### args
When a module calls another module, it passes values for parameters via the `args` key.

Values can be supplied in multiple different ways:
- Literal data: e.g. `foo`, `123`. `[false]`, `{foo: bar}` etc.
- References to parameters (as defined in `params`): `pt.param my-param`
- References to values: `pt.value my-value`.  Values are data (typically strings) that have been provided separately by the user. **IMPORTANT** `pt.value` cannot be accessed in a `#pt-clj` script. 
- References to secrets: `pt.secret my-secret`. Secrets are sensitive data (typically strings) that have been provided separately by the user. **IMPORTANT** `pt.secret` cannot be accessed in a `#pt-clj` script.
- Interpolated strings: strings that contain references to params, values or secrets, e.g. `http://{pt.param domain}:{pt.value port}/foo?api-key={pt.secret my-secret-key}`
- Code: TODO

Arg values can be any data but _MUST_ match the type spec of the corresponding param in the referenced module.

#### Example

**CORRECT**
```yaml
module: the-module-were-calling  # module defined elsewhere, with params matching the args below
args:
    some-string-param: "hello world"      # plain string
    some-complex-param: [foo, {foo: bar}] # plain data
    some-param: pt.value foo              # reference to a value
    some-param-2: pt.secret foo           # reference to a secret
    some-param-3:
        foo: "interpolated string with a value: {pt.value foo}"
        bar: [pt.param bar, pt.secret baz] # data with inline references
```

**WRONG**
```yaml
    some-param: "#pt-clj (Integer/parseInt (pt.value \"foo\"))"    # This will throw an error since pt.value is not available in `#pt-clj` scripts.
```

#### Param type DSL

The param type DSL is how types are defined in Polytope.

Basic types:
- `str`: strings
- `bool`: `true` or `false`
- `int`: integers
- `num`: any number

Compound types:
- `[...]`: list of elements matching a given type (e.g. `[int]`, `[bool]`).
- `{...}`: map of named keys whose values match provided types (e.g. `{foo: int, bar: str}`)
- `[either, ...]`: union type (e.g. `[either, str, int]`, `[either, str, [str], int, {foo: int}]`)
- `[default, $type, $value]`: type with a default value (e.g. `[default, str, "my-default-value"]`)
- `[enum, ...]`: enum type (e.g. `[enum, 1, 2, "foo"]`)
- `[maybe, $type]`: marks a type as optional.
- `[regex, $regex]`: string type constrained to match the given regex.

There are also type aliases for commonly used types:
- `env-var`: equivalent to `{name: str, value: str}`
- `mount-source`: defined as `MountSourceSpec` in the definitions file. Intended for specifying data to be mounted containers. Examples:
  - `{type: host, path: /foo/bar}`: a path on the host machine to mount into the container. If a relative path like `some/folder` is provided, this is relative to the directory of the `polytope.yml` file. If a relative path with a leading `./`path like `./some/other/folder` is provided, it's relative to the current working directory.
  - `{type: string, data: my-string}`: literal string mounted as a file.
  - `{type: volume, scope: project, id: my-volume}`: a named volume. By default gets created if it doesn't already exist. Persisted across jobs ONLY IF `scope: project` is set.
- `service-spec`: a service specification. Must match `ServiceSpec` in the defiitions file. Keys:
  - `id`: the ID of the created service. Required.
  - `ports`: a list of named port mappings. `ServicePortsSpec` in the defiitions file. Each spec has the following keys:
    - `port`: the port on the container side.
    - `protocol`: the protocol being routed.
    - `expose-as`: the port on the host machine to which the port is mapped.

### Templates
`templates` holds a list of template specs. These specs must adhere to the `TemplateSpec` type in the definitions file.

The following keys are supported when defining a template:
- `id`: Uniquely identifies a template. May only contain '0–9', 'a–z', '_', and '-'. Required.
- `info`: Optional info string about the template.
- `params`: Parameter declarations for the template. Works the same way as for modules. Optional.
- `run`: A list of steps to run. Required. Explained below.

#### Steps
Steps may be provided in one of the following ways:

Plain module references, with no arguments:
```yaml
run:
  - my-module
  - polytope/hello-world
```

Or with arguments:
```yaml
run:
  - module: my-module
    args:
      foo: bar
      baz: 123
  - module: polytope/hello-world
    args:
      message: "Hello, world!"
```

By default, steps get their ID from the module ID. If you want to override this, you can specify the `id` key:
```yaml
run:
  - id: hello-world
    module: polytope/hello-world
    args:
      message: "Hello, world!"
  - id: aiya-ambar
    module: polytope/hello-world
    args:
      message: "Aiya Ambar!"
```

Steps run in parallel by default, but sequencing can be enforced by using `run-when`:
```yaml
run:
  - id: hello-world
    module: polytope/container
    args:
      image: ubuntu
      cmd: "echo Hello, world!"
  - id: hello-world
    module: polytope/hello-world
    args:
      message: "Hello world again!"
    run-when:
      after: hello-world # this step will run after the hello-world step, _INCLUDING THE ASSOCIATED CONTAINER_ completes
```


# Instructions to follow when generating code that should run on Polytope

## File structure and ordering
Always place the `templates` section at the top of the `polytope.yml` file, above the `modules` section. This makes it easy for developers to see which templates are available. 

✅ **CORRECT**:
```yaml
templates:
  - id: stack
    run:
      - api
      - database

modules:
  - id: api
    module: polytope/python
    # ... module definition
  - id: database
    module: polytope/postgres
    # ... module definition
```

❌ **WRONG**:
```yaml
modules:
  - id: api
    # ... module definition

templates:  # Templates should come first!
  - id: stack
    run:
      - api
```

## Concise template section
Make the template section of the polytope.yml file as short as possible. Define modules under the modules section or use pre-existing Polytope modules and refer to them from the template run section.

Keep names simple, and don't set other ids in templates unless you have multiple calls to the same module.

Don't needlessly add template params. The default params on the module should be sufficient for most use cases.

## Adding modules and templates
Whenever adding a module or template to the polytope.yml file, first check if there is a Blueprint for this type of module or template. **IMPORTANT: If the Blueprint includes a `boilerplate.md` file, use the `boilerplate` module to generate the initial code for the module or template!**

Module code should be placed under the `./modules/<module-id>` directory.

## Give modules sensible parameters
Try to provide default values for all parameters in the modules you write. Prefer parameters to 'hard-coding' values in the module, especially if they're repeated or can be expected to change.

## No hard coded property values that the user may want to change between deployment environments
In the polytope.yml file, all values that may change between deployment environment should be dynamically loaded from Polytope secrets and values, e.g. all ports, hostnames, and protocols should be stored as Polytope values and all usernames, passwords and api keys should be stored as Polytope secrets. All property values specified in a ServiceSpec or EnvVarSpec should be referenced as Polytope values, e.g. port: pt.value api_port. Ensure that no property value inside of a ServiceSpec of EnvVarSpec is hard coded.

## Correct type for args
Make sure that modules get the correct type of parameters. When a module expects an int but gets a str, it will fail. Error example: Must be an integer (got "8079"). Polytope values and secrets are always of type str.


## Hostnames
The hostnames that web apps need, must be based on Polytope values, so they can be dynamically set to different values in deployment different environments.

The Polytope service hostnames that are accessible internally within a template are not available to a web browser or any other software running outside of Polytope.

## In templates, don't provide `after` unless steps must wait for another step to complete
**CRITICAL**: In a Polytope template that defines a stack of services, NEVER use `run-when: after` for services!

Services that use `polytope/container` BLOCK until the container shuts down. Using `after` would mean waiting forever!

❌ **WRONG**:
```yaml
run:
  - redpanda
  - module: api
    run-when:
      after: redpanda  # This will wait forever!
```

✅ **CORRECT**:
```yaml
run:
  - redpanda
  - api  # Runs concurrently!
  - web-app  # All services start together
```

All services must be fault-tolerant and handle connection failures gracefully with retries.

## Code that depends on other services, must assume those services may be down
All code that you generate must be resilient to services that the code depends on may be down, such as databases and message queues. These services may not have started yet, they could be temporary out of order, or they could be restarting. 

## Executables
Ensure that all files to be executed are executable.

## ALWAYS use persistent volumes for stateful services
**CRITICAL**: Services like databases, message queues, and caches MUST have persistent volumes or data will be lost on restart.

❌ **WRONG**:
```yaml
templates:
  - id: stack
    run:
      - polytope/redpanda  # NO! Data will be lost!
```

✅ **CORRECT**:
```yaml
templates:
  - id: stack
    run:
      - redpanda  # Uses your wrapper with volume

modules:
  - id: redpanda
    module: polytope/redpanda
    args:
      data-volume:
        type: volume
        scope: project # ALWAYS use project scope for persistent data! The default scope is job, which is ephemeral.
        id: redpanda-data
```

## Module inheritance
Try to stick to the built-in modules. If there's no suitable module for what you're trying to achieve, create a custom module that calls `polytope/container`.

## Polytope file layout
Prefer creating modules for the different execution units of your application, e.g. web-app, api, redpanda, etc. Avoid putting module data directly in templates if it makes sense to be able to run the module directly.

## Write stuff to be run in Polytope
Want to create a test script? Put it in a separate directory and create a module for it (is it a shell script? just use `polytope/container` with `image: alpine` or whatever). Ditto for any other runnable units of code!

If you have different commands in your app, create corresponding run scripts in `bin/` and create a specialized module, e.g.:
```yaml
modules:
  - id: api
    module: polytope/python
    params:
      - id: cmd
        type: [default, str, "bin/run"]
    args:
      id: my-app
      image: python:3.13-slim
      code: { type: host, path: ./modules/api }
      cmd: pt.param cmd

  - id: api-test
    module: api
    params: {cmd: "bin/test"}

  - id: api-ipython
    module: api
    params: {cmd: "bin/ipython"}
```

# Polytope Data Types And Specification
```yaml
$schema: https://json-schema.org/draft/2020-12/schema
$id: https://example.com/schemas/polytope-data-types
title: Polytope Data Types
description: Comprehensive schema for all Polytope data types based on the provided documentation.
type: object
additionalProperties: true
definitions:
  Code:
    title: Code
    type: string
    description: Representation of code, prefixed with language identifier or raw Clojure form.
    oneOf:
      - pattern: "^#(pt-js|pt-py|pt-clj)\\s.*$"
      - type: string
  CronExpr:
    title: CronExpr
    type: string
    description: Cron schedule expression, e.g., '15 3 * * *'.
  DatasetRef:
    title: DatasetRef
    type: string
    description: Reference to a dataset, e.g., 'my-dataset' or 'my-org/my-project>dataset:my-dataset'.
    pattern: "^[a-z0-9_-]+(>[a-z0-9_-]+>dataset:[a-z0-9_-]+)?$"
  EnvVarSpec:
    title: EnvVarSpec
    type: object
    properties:
      name:
        type: string
      value:
        oneOf:
          - type: string
          - type: string
          - type: boolean
          - type: integer
    required:
      - name
    additionalProperties: false
  Id:
    title: Id
    type: string
    pattern: "^[a-z0-9_-]+$"
  ModuleRef:
    title: ModuleRef
    type: string
    pattern: "^[a-z0-9_-]+/[a-z0-9_-]+(@[a-zA-Z0-9_-]+)?(:[a-z0-9_-/]+)?(![a-z0-9_-]+)?$"
  ModuleSpec:
    title: ModuleSpec
    type: object
    properties:
      api-version:
        type: string
      args:
        type: object
        additionalProperties: true
        patternProperties:
          "^[a-z0-9_-]+$": {}
      code:
        $ref: "#/definitions/Code"
      default?:
        type: boolean
      id:
        $ref: "#/definitions/Id"
      info:
        type: string
      module:
        $ref: "#/definitions/ModuleRef"
      params:
        type: array
        items:
          type: object
          properties:
            id:
              $ref: "#/definitions/Id"
            info:
              type: string
            name:
              type: string
            type:
              description: Parameter data type format.
          required:
            - id
            - type
          additionalProperties: false
    oneOf:
      - required: [code]
      - required: [module]
    required:
      - id
    additionalProperties: false
  MountSourceSpec:
    title: MountSourceSpec
    oneOf:
      - type: object
        properties:
          dataset:
            oneOf:
              - $ref: "#/definitions/DatasetRef"
              - $ref: "#/definitions/Uid"
          path:
            type: string
          type:
            type: string
            const: "dataset"
          version:
            type: integer
        required:
          - dataset
          - type
        additionalProperties: false
      - type: object
        properties:
          path:
            type: string
          type:
            type: string
            const: "host"
        required:
          - path
          - type
        additionalProperties: false
      - type: object
        properties:
          path:
            type: string
          repo:
            oneOf:
              - $ref: "#/definitions/RepoRef"
              - $ref: "#/definitions/Uid"
          revision:
            type: string
          type:
            type: string
            const: "repo"
        required:
          - type
        additionalProperties: false
      - type: object
        properties:
          data:
            type: string
          type:
            type: string
            const: "string"
        required:
          - data
          - type
        additionalProperties: false
      - type: object
        properties:
          create:
            type: string
            enum: ["never", "when-missing", "always"]
          id:
            $ref: "#/definitions/Id"
          scope:
            type: string
            enum: ["project", "job"]
          source:
            $ref: "#/definitions/MountSourceSpec"
          type:
            type: string
            const: "volume"
        required:
          - type
        additionalProperties: false
  PolytopeFile:
    title: PolytopeFile
    type: object
    properties:
      modules:
        type: array
        items:
          $ref: "#/definitions/ModuleSpec"
      templates:
        type: array
        items:
          $ref: "#/definitions/TemplateSpec"
    additionalProperties: false
  RepoRef:
    title: RepoRef
    type: string
    pattern: "^[a-z0-9_-]+/[a-z0-9_-]+(/[a-z0-9_-]+)?$"
  ServicePortsSpec:
    title: ServicePortsSpec
    oneOf:
      - type: object  # Single port
        properties:
          expose-as:
            type: integer
          internal:
            type: boolean
          label:
            $ref: "#/definitions/Id"
          port:
            type: integer
          protocol:
            type: string
            enum: ["tcp", "udp", "http", "https"]
        required:
          - port
          - protocol
        additionalProperties: false
      - type: object  # Port range
        properties:
          expose-as:
            type: string
          internal:
            type: boolean
          label:
            $ref: "#/definitions/Id"
          protocol:
            type: string
            enum: ["tcp", "udp", "http", "https"]
          range:
            type: string
        required:
          - protocol
          - range
        additionalProperties: false
  TemplateSpec:
    title: TemplateSpec
    type: object
    properties:
      id:
        $ref: "#/definitions/Id"
      info:
        type: string
      run:
        type: array
        items:
          oneOf:
            - type: object
              properties:
                args:
                  type: object
                  additionalProperties: true
                  patternProperties:
                    "^[a-z0-9_-]+$": {}
                id:
                  $ref: "#/definitions/Id"
                module:
                  $ref: "#/definitions/ModuleRef"
                run-when:
                  type: object
                  properties:
                    after:
                      type: string
                    after-condition:
                      type: string
                      enum: ["success", "always", "failed"]
                  additionalProperties: false
              required:
                - module
              additionalProperties: false
            - $ref: "#/definitions/ModuleRef"
    required:
      - id
      - run
    additionalProperties: false
  Uid:
    title: Uid
    type: string
    pattern: "^[0-9a-f]{16}$"

```


# Values and Secrets

Polytope provides a built-in key-value store for configuration data through **values** (non-sensitive) and **secrets** (sensitive). This enables environment-specific configuration without hardcoding values in `polytope.yml`.

## Key Principles

### 1. Use Values and Secrets for All Environment-Specific Data
**CRITICAL**: All configuration that varies between environments must use Polytope values and secrets:
- **Values**: Ports, hostnames, protocols, URLs, feature flags
- **Secrets**: Passwords, API keys, tokens, certificates

### 2. No Hardcoded Configuration
All property values in `ServiceSpec` and `EnvVarSpec` should reference Polytope values/secrets:

❌ **WRONG**:
```yaml
env:
  - name: API_PORT
    value: 8080  # Hardcoded!
```

✅ **CORRECT**:
```yaml
env:
  - name: API_PORT
    value: pt.value api-port
```

## Usage in polytope.yml

### Basic References
```yaml
modules:
  - id: api
    args:
      env:
        - name: DATABASE_HOST
          value: pt.value db-host
        - name: DATABASE_PASSWORD
          value: pt.secret db-password
```

### String Interpolation
```yaml
env:
  - name: DATABASE_URL
    value: "postgresql://{pt.secret db_user}:{pt.secret db_password}@{pt.value db-host}:{pt.value db-port}/mydb"
```

## Type Conversion Pattern

**IMPORTANT**: Polytope values and secrets are always strings, even if set as numbers. When modules require non-string types (like integers), use the two-module pattern:

### Pattern: Top-Level + Base Module

✅ **CORRECT**:
```yaml
modules:
  # Top-level module: handles value/secret dereferencing
  - id: api
    module: api-base
    args:
      port: pt.value api-port
      db-host: pt.value db-host

  # Base module: handles type conversion and logic
  - id: api-base
    params:
      - id: port
        type: [default, str, "8080"]
      - id: db-host
        type: [default, str, "localhost"]
    module: polytope/python
    args:
      port: "#pt-clj (Integer/parseInt (:port params))"  # Convert string to int
      env:
        - name: DB_HOST
          value: pt.param db-host  # String is fine
```

### Critical Rules for #pt-clj Scripts

#### `pt.value` and `pt.secret` are NOT available in `#pt-clj` scripts

**WRONG**:
```yaml
port: "#pt-clj (Integer/parseInt (:api-port pt.value))"  # pt.value not available!
```

#### The modules param map is available as `params` in `#pt-clj` scripts

**CORRECT**:
```yaml
port: "#pt-clj (Integer/parseInt (:api-port params))"
```

## Setting Values and Secrets

Values and secrets are set using the Polytope CLI:

```bash
# Set a value
pt values set api-port 8080

# Set a secret
pt secrets set db-password mypassword

# Set from file
pt values set --file config.yaml
```

## Default Values Setup

Create `.values_and_secrets.defaults.sh` with default values for easy project setup:

```bash
#!/bin/bash
# Default values and secrets for development

# Values
pt values set api-port 8080
pt values set db-host localhost
pt values set db-port 5432

# Secrets (use placeholder values)
pt secrets set db-password changeme
pt secrets set api-key your-api-key-here
```

Add to `.gitignore`:
```
.values_and_secrets.sh
```

This allows users to create `.values_and_secrets.sh` with real values locally without committing them.
